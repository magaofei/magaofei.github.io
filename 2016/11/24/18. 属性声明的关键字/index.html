<!DOCTYPE html>
<html lang="zh-CN">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Objective-C属性声明的关键字"/><meta name="keywords" content="iOS, 马面的部落格" /><link rel="alternate" href="/atom.xml" title="马面的部落格"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />
<link rel="canonical" href="https://magaofei.github.io/2016/11/24/18. 属性声明的关键字/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-86730422-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-86730422-1');
</script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "U8yQE4F47ieQpwPbbFodk8IX-gzGzoHsz",
      appKey: "1i3I2spUT9rGlts0cWBGKLsv"
    });
  </script><script>
  window.config = {"leancloud":{"app_id":"U8yQE4F47ieQpwPbbFodk8IX-gzGzoHsz","app_key":"1i3I2spUT9rGlts0cWBGKLsv"},"toc":"","fancybox":"","pjax":"","latex":""};
</script>

    <title>Objective-C属性声明的关键字 - 马面的部落格</title>
  <meta name="generator" content="Hexo 4.2.1"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">马面的部落格</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags">
        <li class="mobile-menu-item">标签
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">马面的部落格</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            标签
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Objective-C属性声明的关键字
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-11-24
        </span><span class="post-visits"
             data-url="/2016/11/24/18.%20%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"
             data-title="Objective-C属性声明的关键字">
          阅读次数 0
        </span>
        </div>
    </header>

    <div class="post-content"><h1 id="Objective-C声明属性的关键字介绍"><a href="#Objective-C声明属性的关键字介绍" class="headerlink" title="Objective-C声明属性的关键字介绍"></a>Objective-C声明属性的关键字介绍</h1><h3 id="readonly和readwrite"><a href="#readonly和readwrite" class="headerlink" title="readonly和readwrite"></a><code>readonly</code>和<code>readwrite</code></h3><h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>只有getter方法，没有setter方法，杜绝了从外部访问属性的可能，但是在本身也无法使用self调用方法</p>
<p>解决方法：把属性的声明写在.m文件中，可以避免外界的访问，也可以在本身使用self调用方法</p>
<p>默认是readwrite</p>
<h3 id="strong-vs-weak"><a href="#strong-vs-weak" class="headerlink" title="strong vs weak"></a>strong vs weak</h3><p>不同</p>
<ul>
<li>引用计数+1</li>
</ul>
<p>strong是强引用，属性声明时默认就是强引用</p>
<h4 id="注意：强引用循环-循环引用现象"><a href="#注意：强引用循环-循环引用现象" class="headerlink" title="注意：强引用循环/循环引用现象"></a>注意：强引用循环/循环引用现象</h4><p>说明：循环引用是指，两个对象之间相互强引用，导致无法被释放，造成内存泄露。一般是存在父子关系的时候容易发生这种现象，比如两个包类，其中背包里面拥有钱包。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来自《iOS编程》第四版</span></span><br><span class="line"><span class="comment">// BNRItem.h</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) BNRItem *containedItem;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) BNRItem *container;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BNRItem.m</span></span><br><span class="line">- (<span class="keyword">void</span>)setContainedItem:(BNRItem *)containedItem &#123;</span><br><span class="line">    _containedItem = containedItem;</span><br><span class="line">  <span class="comment">// 将item加入容纳它的BNRItem对象时，</span></span><br><span class="line">  <span class="comment">// 会将它的container实例变量指向容纳它的对象</span></span><br><span class="line">    <span class="keyword">self</span>.containedItem.container = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Destroyed %@"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"BNRItem.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个NSMutableArray对象，并用items变量保存该对象的地址</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *items = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        BNRItem *backpack = [[BNRItem alloc] initWithItemName:<span class="string">@"Backpack"</span>];</span><br><span class="line">        [items addObject:backpack];</span><br><span class="line">        </span><br><span class="line">        BNRItem *calculator = [[BNRItem alloc] initWithItemName:<span class="string">@"Calculator"</span>];</span><br><span class="line">        [items addObject:calculator];</span><br><span class="line">        </span><br><span class="line">        backpack.containedItem = calculator;</span><br><span class="line">        </span><br><span class="line">        backpack = <span class="literal">nil</span>;</span><br><span class="line">        calculator = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">for</span> (BNRItem *item <span class="keyword">in</span> items) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Setting items to nil...."</span>);</span><br><span class="line">        items = <span class="literal">nil</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//此时输出结果是</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  2016-11-24 13:50:44.023481 RandomItems[36837:2040846] Backpack () :Worth $0, recorded on 2016-11-24 05:50:44 +0000</span></span><br><span class="line"><span class="comment">2016-11-24 13:50:44.023586 RandomItems[36837:2040846] Calculator () :Worth $0, recorded on 2016-11-24 05:50:44 +0000</span></span><br><span class="line"><span class="comment">2016-11-24 13:50:44.023605 RandomItems[36837:2040846] Setting items to nil....</span></span><br><span class="line"><span class="comment">Program ended with exit code: 0</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
<p>由于我们重写了dealloc方法，在对象即将被释放时，应该调用dealloc方法，这里并没有调用，说明这两个对象并没有正常释放。</p>
<p>首先确定父子关系，确定之后，让父对象拥有子对象，子对象不能拥有父对象，比如backpack是父对象，calculator是子对象，根据这个规则名，将backpack指向<code>calculator(_containedItem)</code>的指针保留为强引用，将calculator指向<code>backpack(_container)</code>的指针保留为弱引用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) BNRItem *container;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">2016-11-24 14:10:18.675480 RandomItems[37054:2053319] Backpack () :Worth $0, recorded on 2016-11-24 06:10:18 +0000</span></span><br><span class="line"><span class="comment">2016-11-24 14:10:18.675578 RandomItems[37054:2053319] Calculator () :Worth $0, recorded on 2016-11-24 06:10:18 +0000</span></span><br><span class="line"><span class="comment">2016-11-24 14:10:18.675595 RandomItems[37054:2053319] Setting items to nil....</span></span><br><span class="line"><span class="comment">2016-11-24 14:10:18.675635 RandomItems[37054:2053319] Destroyed Backpack () :Worth $0, recorded on 2016-11-24 06:10:18 +0000</span></span><br><span class="line"><span class="comment">2016-11-24 14:10:18.675929 RandomItems[37054:2053319] Destroyed Calculator () :Worth $0, recorded on </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>比如背包和钱包是同一品牌的产品，我们用一个类来代替，类中有两个属性，(containedItem)一个是里面放了什么东西，(container)一个是被什么东西包含了，在把钱包放入背包后，背包的containedItem指向了钱包，而钱包的container指向了背包，就造成了循环引用，解决方法是，把钱包的指向改为弱引用。</p>
<h3 id="strong-vs-assign"><a href="#strong-vs-assign" class="headerlink" title="strong vs assign"></a>strong vs assign</h3><p>不同</p>
<ul>
<li>strong修饰OC对象</li>
<li>strong强引用，引用计数+1</li>
</ul>
<ul>
<li>assign修饰非OC对象</li>
<li>assign拷贝值，不做引用计数</li>
</ul>
<p>assign可以用在非OC对象上吗？</p>
<p>可以，但不会做引用计数+1</p>
<h3 id="weak-vs-assign"><a href="#weak-vs-assign" class="headerlink" title="weak vs assign"></a>weak vs assign</h3><p>相同</p>
<ul>
<li>可以修饰OC对象</li>
<li>不做强引用，引用计数不加1</li>
</ul>
<p>不同</p>
<ul>
<li>weak在对象释放时自动置为nil</li>
<li>assign保留原始值，释放对象时不会置为nil（不安全）(unsafe_unretained)</li>
</ul>
<p>场景：在对象被释放之后，weak会将对象置为nil，准确的说是对象的地址置为nil，而assign则不会，所以就有可能发生一种现象，如果对象被释放了，而assign修饰的对象的指针还在指向着那块内存地址，当其他对象使用了这块内存地址时，就容易发生冲突，基础类型不会发生这种情况，所以我们应该使用weak来修饰对象，用assign来修饰基础类型。</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>使用copy关键字声明属性，在使用过程中，内部会调用copyWithZone方法，重新生成一个新的不可变的类型并赋值返回，这样做的好处是，当拥有一个可变类型的子类来使用时，就可以避免可变类型的子类对象进行的反复修改，避免导致不可控现象。</p>
<p>举例说明</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSMutableString</span> *mutableString = [[<span class="built_in">NSMutableString</span> alloc] init];</span><br><span class="line">        mutableString = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"1234"</span>];</span><br><span class="line">        Person *p1 = [[Person alloc] init];</span><br><span class="line">        </span><br><span class="line">        p1.name = mutableString;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"p1.name = %@ --&gt; %p"</span>, p1.name, p1.name);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"mutableString = %@ --&gt; %p"</span>, mutableString, mutableString);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"appendString之后"</span>);</span><br><span class="line">        [mutableString appendString:<span class="string">@"5"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"p1.name = %@"</span>, p1.name);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"mutableString = %@"</span>, mutableString);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用copy关键字声明的name</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2016-11-24 13:25:12.320037 copy[36455:2025654] p1.name = 1234 --&gt; 0x3433323145</span></span><br><span class="line"><span class="comment">2016-11-24 13:25:12.321110 copy[36455:2025654] mutableString = 1234 --&gt; 0x1003065a0</span></span><br><span class="line"><span class="comment">2016-11-24 13:25:12.321189 copy[36455:2025654] appendString之后</span></span><br><span class="line"><span class="comment">2016-11-24 13:25:12.321433 copy[36455:2025654] p1.name = 1234</span></span><br><span class="line"><span class="comment">2016-11-24 13:25:12.321475 copy[36455:2025654] mutableString = 12345</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在执行完毕<code>p1.name = mutableString;</code>之后，两个指针的地址就不同了，这就是因为重新生成了一个地址来指向<code>p1.name</code>，并且是不可变类型的。而<code>mutableString</code>还在那里。</p>
<p>缺点：频繁使用会造成内存的浪费，所以我们只在必要时使用</p>
<h3 id="nonatomic-vs-atomic"><a href="#nonatomic-vs-atomic" class="headerlink" title="nonatomic vs atomic"></a>nonatomic vs atomic</h3><p>在iOS上我们用nonatomic，默认时atomic，所以我们要将其声明</p>
<p>说明，两者的区别是使用时保证线程安全，在多线程中调用属性可能会发生线程锁的问题，不过苹果声明，在iOS上不必考虑这个问题，缺点是会影响性能。</p>
<h3 id="getter-vs-setter"><a href="#getter-vs-setter" class="headerlink" title="getter vs setter"></a>getter vs setter</h3><p>可以用来指定getter和setter的方法名，常用于BOOL中</p>
<p>如有错误，欢迎指正</p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://magaofei.github.io">mark</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://magaofei.github.io/2016/11/24/18.%20%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/">https://magaofei.github.io/2016/11/24/18.%20%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/iOS/">iOS</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2016/11/25/19.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A%E6%8F%92%E5%BA%A7%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">为什么要把插座变量声明为弱引用？</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2016/11/23/17.%20%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%99%E6%B3%95/">
        <span class="next-text nav-default">指针变量的写法</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"><div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:mamian521#email.com" class="iconfont icon-email" title="email"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">mark</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://magaofei.github.io/2016/11/24/18.%20%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/';
        this.page.identifier = '2016/11/24/18. 属性声明的关键字/';
        this.page.title = 'Objective-C属性声明的关键字';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//wantme.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
</body>
</html>
